### class01 

#### 选择排序

#### 冒泡排序

#### 插入排序


### class02

#### 归并排序

先小范围有序，再大范围有序 ==> 先拆分到最小，再合并排序

小和问题：右边比左边小的数

暴力

1 3 4 2 5 

1*4+3*2+4*1+2*1

逆序对：右边比左边小的数右多少个

3 2 4 5 0

3 2、3 0、2 0、4 0、5 0

#### 堆排

      0
      
  1       2
  
3    4  5   6

左孩子奇，右孩子偶
left = 2 * index + 1;
right = left + 1;
parent = (index - 1) / 2


升序大根堆，降序小根堆

#### 快排

小于区、等于区、大于区

先大范围有序，再小范围有序

小于区推着等于区域往右走

0-1标准问题  

奇数放一边、偶数放一边

=======================================

### class03 记数排序、基数排序

不基于比较的排序，需要根据具体的数据状况实现

稳定性：可以做到

一个萝卜一个坑

#### 计数排序

要求：数据范围可以确定  

桶个数 == 数据范围

#### 基数排序

要求：数据进制可以确定，

桶个数 == 进制

=======================================

### class04 链表

1)对于笔试，不用太在乎空间复杂度，一切为了时间复杂度，要做到能够code出来

2)对于面试，时间复杂度依然放在第一位，但是一定要找到空间最省的方法，做到要有清晰的思路

重要技巧: 

1)额外数据结构记录(哈希表等)

2)快慢指针

### class05 二叉树

#### 搜索二叉数

1、左子树都小于当前节点，右子树都大于当前节点
2、中序遍历为有序
3、树型DP【

左树：搜索树

右树：搜索树

左树：最大值 < x

右树：最小值 > x

===> 左树是否是搜索二叉树，以及最大值

===> 右树是否是搜索二叉树，以及最小值

求并集：
===> 是否是搜索二叉树，最大值，最小值】

#### 平衡二叉树

左子树和右子树的高度 <= 1

树形DP：

左子树：平衡树

右子树：平衡树

|左高-右高| < 2

#### 完全二叉数

 基于宽度优先遍历
 
 1、任一节点，有右无左，返回false
 
 2、第一个左右不全的地方，后续的所有节点都为叶节点

#### 满二叉树

nodes = 2^height - 1

#### 树型DP

### 图





















