    
主流程：

    定义主函数：arr[L.....R]上有序
    =====> arr[L.....M]上有序，arr[M+1.....R]上有序，将两个有序的部分合并

伪代码：

    让arr[L......R]上有序：
    {
        拆分到最细：M = L + (R - L) / 1;
        让arr[L......M]上有序
        让arr[M+1......R]上有序
        将两个有序的部分合并
    }

- 树形递归
- 深度优先遍历？？
- 先拆分到最细，再merge

经典题目：

    小和问题：
    逆序对问题：
    while (p1 <= M && p2 <= R) {
    	// 左右相等时，拷贝右边，不累加到结果里
    	res += arr[p1] < arr[p2] ? arr[p1] * (R - p2 + 1) : 0;
    	help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
	}
    


    